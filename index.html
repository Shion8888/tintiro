<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Chinchiro ‚Äì Final</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #111;
  color: #fff;
  font-family: system-ui, sans-serif;
}
#btn {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 14px 28px;
  font-size: 18px;
  border-radius: 12px;
  border: none;
  background: #ffcc00;
  font-weight: bold;
  cursor: pointer;
}
#result {
  position: fixed;
  top: 14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 22px;
  text-align: center;
  white-space: pre;
}
</style>
</head>
<body>

<div id="result"></div>
<button id="btn">„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã</button>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

/* ===============================
   „Çµ„Ç§„Ç≥„É≠ÁõÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£
================================ */
function createDiceTexture(n) {
  const c = document.createElement("canvas");
  c.width = c.height = 256;
  const ctx = c.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,256,256);
  ctx.fillStyle = "#000";

  const r = 18;
  const p = {
    tl:[64,64], tr:[192,64],
    ml:[64,128], mr:[192,128],
    bl:[64,192], br:[192,192],
    mc:[128,128]
  };
  const map = {
    1:["mc"], 2:["tl","br"], 3:["tl","mc","br"],
    4:["tl","tr","bl","br"],
    5:["tl","tr","mc","bl","br"],
    6:["tl","ml","bl","tr","mr","br"]
  };
  map[n].forEach(k=>{
    ctx.beginPath();
    ctx.arc(...p[k], r, 0, Math.PI*2);
    ctx.fill();
  });
  return new THREE.CanvasTexture(c);
}

function materialsForValue(v){
  return [
    new THREE.MeshStandardMaterial({ map: createDiceTexture(2) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(5) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(v) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(7-v) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(3) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(4) }),
  ];
}

/* ===============================
   Âá∫ÁõÆ ‚Üí ÂõûËª¢
================================ */
function quaternionForValue(v) {
  const q = new CANNON.Quaternion();
  switch (v) {
    case 1: q.setFromEuler(0,0,0); break;
    case 2: q.setFromEuler(0,0,Math.PI/2); break;
    case 3: q.setFromEuler(Math.PI/2,0,0); break;
    case 4: q.setFromEuler(-Math.PI/2,0,0); break;
    case 5: q.setFromEuler(0,0,-Math.PI/2); break;
    case 6: q.setFromEuler(Math.PI,0,0); break;
  }
  return q;
}

/* ===============================
   Three / Cannon
================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 15, 0);
camera.lookAt(0,0,0);
camera.up.set(0,0,-1);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.7));

const world = new CANNON.World();
world.gravity.set(0,-9.82,0);

const floor = new CANNON.Body({ mass:0 });
floor.addShape(new CANNON.Plane());
floor.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(floor);

/* ===============================
   „Å©„Çì„Å∂„Çä
================================ */
const R = 6;
const inner = new THREE.Mesh(
  new THREE.CircleGeometry(R-0.3,64),
  new THREE.MeshStandardMaterial({ color:0x8b5a2b })
);
inner.rotation.x = -Math.PI/2;
scene.add(inner);

const rim = new THREE.Mesh(
  new THREE.RingGeometry(R-0.3,R,64),
  new THREE.MeshStandardMaterial({ color:0xff0000 })
);
rim.rotation.x = -Math.PI/2;
rim.position.y = 0.01;
scene.add(rim);

/* ===============================
   „Çµ„Ç§„Ç≥„É≠
================================ */
const diceMeshes=[], diceBodies=[], values=[1,1,1];
for(let i=0;i<3;i++){
  const m=new THREE.Mesh(
    new THREE.BoxGeometry(0.6,0.6,0.6),
    materialsForValue(1)
  );
  scene.add(m); diceMeshes.push(m);

  const b=new CANNON.Body({
    mass:1,
    shape:new CANNON.Box(new CANNON.Vec3(0.3,0.3,0.3))
  });
  world.addBody(b); diceBodies.push(b);
}

/* ===============================
   Âà§ÂÆö
================================ */
function judge(v){
  const s=[...v].sort();
  if(v[0]==v[1]&&v[1]==v[2]) return v[0]==1?"üéâ „Éî„É≥„Çæ„É≠":"‚ö° „Ç¢„É©„Ç∑";
  if(s+""==="1,2,3") return "üíÄ „Éí„Éï„Éü";
  if(s+""==="4,5,6") return "üî• „Ç∑„Ç¥„É≠";
  if(v[0]==v[1]||v[1]==v[2]||v[0]==v[2]) return "üëâ ÂΩπ„ÅÇ„Çä";
  return "üòê ÂΩπ„Å™„Åó";
}

/* ===============================
   „Éú„Çø„É≥
================================ */
let shonben=false;

btn.onclick=()=>{
  shonben=false;
  result.textContent="";

  diceBodies.forEach((b,i)=>{
    b.position.set((i-1)*0.9,1.6,0);
    b.velocity.setZero();
    b.angularVelocity.setZero();

    const a=Math.random()*Math.PI*2;
    b.velocity.set(Math.cos(a)*3.2,2.0,Math.sin(a)*3.2);
    b.angularVelocity.set(4,4,4);

    values[i]=Math.floor(Math.random()*6)+1;
  });

  setTimeout(()=>{
    if(shonben){
      result.textContent="üí¶ „Ç∑„Éß„É≥„Éô„É≥";
    }else{
      diceBodies.forEach((b,i)=>{
        b.quaternion.copy(quaternionForValue(values[i]));
        b.angularVelocity.setZero();
        diceMeshes[i].material=materialsForValue(values[i]);
      });
      result.textContent=`Âá∫ÁõÆÔºö${values.join(" , ")}\n${judge(values)}`;
    }
  },2600);
};

/* ===============================
   „É´„Éº„Éó
================================ */
function animate(){
  requestAnimationFrame(animate);
  world.step(1/60);

  diceBodies.forEach((b,i)=>{
    if(Math.hypot(b.position.x,b.position.z)>R) shonben=true;
    diceMeshes[i].position.copy(b.position);
    diceMeshes[i].quaternion.copy(b.quaternion);
  });
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
