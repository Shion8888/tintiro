<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Paraboloid Colored Floor Test</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
  }
  #btn {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 24px;
    font-size: 18px;
    border: none;
    border-radius: 12px;
    background: #ffcc00;
    font-weight: bold;
    cursor: pointer;
  }
</style>
</head>
<body>

<button id="btn">サイコロを振る</button>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

/* =====================================================
   Three.js 基本設定
===================================================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 6, 9);
camera.lookAt(0, 0.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 光（凹凸が分かる設定）
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(3, 6, 4);
light.castShadow = true;
scene.add(light);

/* =====================================================
   Cannon-es
===================================================== */
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0)
});

/* =====================================================
   放物面床（色付き）
   y = -K (x^2 + z^2)
===================================================== */
const SIZE = 20;
const DIV  = 128;
const K    = 0.01;   // 非常に浅い（挙動確認用）

// ---------- 物理（Heightfield） ----------
const heights = [];
for (let i = 0; i < DIV; i++) {
  heights.push([]);
  for (let j = 0; j < DIV; j++) {
    const u = (i / (DIV - 1)) * 2 - 1;
    const v = (j / (DIV - 1)) * 2 - 1;
    heights[i][j] = -K * (u * u + v * v);
  }
}

const hfShape = new CANNON.Heightfield(heights, {
  elementSize: SIZE / (DIV - 1)
});

const hfBody = new CANNON.Body({ mass: 0 });
hfBody.addShape(hfShape);
hfBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
hfBody.position.set(-SIZE / 2, 0, -SIZE / 2);
world.addBody(hfBody);

// ---------- 安全用 無限平面（落下防止） ----------
const safetyPlane = new CANNON.Body({ mass: 0 });
safetyPlane.addShape(new CANNON.Plane());
safetyPlane.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
safetyPlane.position.set(0, -2, 0);
world.addBody(safetyPlane);

// ---------- 見た目（色付き放物面） ----------
const geo = new THREE.PlaneGeometry(SIZE, SIZE, DIV - 1, DIV - 1);
geo.rotateX(-Math.PI / 2);

const pos = geo.attributes.position;
const colors = [];

for (let i = 0; i < pos.count; i++) {
  const x = pos.getX(i) / (SIZE / 2);
  const z = pos.getZ(i) / (SIZE / 2);

  const y = -K * (x * x + z * z);
  pos.setY(i, y);

  // 高さ → 色（中央:青 / 外周:黄）
  const t = Math.max(0, Math.min(1, 1 + y / (K * 2)));
  const r = t;
  const g = t * 0.8;
  const b = 1 - t;

  colors.push(r, g, b);
}

geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
geo.computeVertexNormals();

const groundMesh = new THREE.Mesh(
  geo,
  new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide
  })
);
groundMesh.receiveShadow = true;
scene.add(groundMesh);

/* =====================================================
   サイコロ（1個・確認用）
===================================================== */
const DICE_SIZE = 0.6;

const diceMesh = new THREE.Mesh(
  new THREE.BoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE),
  new THREE.MeshStandardMaterial({ color: 0xffffff })
);
diceMesh.castShadow = true;
scene.add(diceMesh);

const diceBody = new CANNON.Body({
  mass: 1,
  shape: new CANNON.Box(
    new CANNON.Vec3(DICE_SIZE / 2, DICE_SIZE / 2, DICE_SIZE / 2)
  ),
  position: new CANNON.Vec3(0, 2.5, 0)
});
world.addBody(diceBody);

/* =====================================================
   ボタン操作
===================================================== */
document.getElementById("btn").onclick = () => {
  diceBody.velocity.setZero();
  diceBody.angularVelocity.setZero();
  diceBody.position.set(0, 2.5, 0);
  diceBody.quaternion.set(0, 0, 0, 1);

  diceBody.applyImpulse(
    new CANNON.Vec3(
      (Math.random() - 0.5) * 0.15,
      0.6,
      (Math.random() - 0.5) * 0.15
    ),
    diceBody.position
  );
};

/* =====================================================
   ループ
===================================================== */
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  world.step(1 / 60, clock.getDelta());

  diceMesh.position.copy(diceBody.position);
  diceMesh.quaternion.copy(diceBody.quaternion);

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
