<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Paraboloid Colored Floor + Stable Dice</title>

<style>
  body { margin: 0; overflow: hidden; background: #111; }
  #btn {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    padding: 14px 24px; font-size: 18px; border: none; border-radius: 12px;
    background: #ffcc00; font-weight: bold; cursor: pointer;
  }
</style>
</head>
<body>

<button id="btn">サイコロを振る</button>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

/* =====================================================
   サイコロの目（Canvas生成）
===================================================== */
function createDiceTexture(n) {
  const c = document.createElement("canvas");
  c.width = c.height = 256;
  const ctx = c.getContext("2d");

  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,256,256);
  ctx.fillStyle = "#000";

  const r = 18;
  const p = {
    tl:[64,64], tr:[192,64],
    ml:[64,128], mr:[192,128],
    bl:[64,192], br:[192,192],
    mc:[128,128]
  };
  const map = {
    1:["mc"], 2:["tl","br"], 3:["tl","mc","br"],
    4:["tl","tr","bl","br"],
    5:["tl","tr","mc","bl","br"],
    6:["tl","ml","bl","tr","mr","br"]
  };
  map[n].forEach(k=>{
    ctx.beginPath();
    ctx.arc(...p[k], r, 0, Math.PI*2);
    ctx.fill();
  });
  return new THREE.CanvasTexture(c);
}

/* =====================================================
   Three.js
===================================================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 6, 9);
camera.lookAt(0, 0.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 光（凹凸が見える）
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(3, 6, 4);
light.castShadow = true;
scene.add(light);

/* =====================================================
   Cannon-es
===================================================== */
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0)
});

/* =====================================================
   放物面床
   物理：浅くして安定
   見た目：誇張して分かりやすく色付け
===================================================== */
const SIZE = 20;
const DIV  = 128;

// 物理用（挙動確認用に浅い）
const K_PHYS = 0.01;

// 見た目用（形が分かるように誇張）
const K_VIS  = 0.30;

// ---------- 物理（Heightfield） ----------
const heights = [];
for (let i = 0; i < DIV; i++) {
  heights.push([]);
  for (let j = 0; j < DIV; j++) {
    const u = (i / (DIV - 1)) * 2 - 1; // [-1,1]
    const v = (j / (DIV - 1)) * 2 - 1;
    heights[i][j] = -K_PHYS * (u*u + v*v);
  }
}

const hfShape = new CANNON.Heightfield(heights, {
  elementSize: SIZE / (DIV - 1)
});

const hfBody = new CANNON.Body({ mass: 0 });
hfBody.addShape(hfShape);

// ★ Heightfield の向きを合わせる（必須）
hfBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);

// 座標合わせ
hfBody.position.set(-SIZE / 2, 0, -SIZE / 2);
world.addBody(hfBody);

// ---------- 安全用 無限床（落下しても消えない） ----------
const safetyPlane = new CANNON.Body({ mass: 0 });
safetyPlane.addShape(new CANNON.Plane());
safetyPlane.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
safetyPlane.position.set(0, -3, 0); // 放物面より十分下
world.addBody(safetyPlane);

// ---------- 見た目（色付き放物面：K_VIS） ----------
const geo = new THREE.PlaneGeometry(SIZE, SIZE, DIV - 1, DIV - 1);
geo.rotateX(-Math.PI / 2);

const pos = geo.attributes.position;
const colors = [];

for (let i = 0; i < pos.count; i++) {
  const x = pos.getX(i) / (SIZE / 2); // [-1,1]
  const z = pos.getZ(i) / (SIZE / 2);

  // 見た目用の誇張放物面
  const y = -K_VIS * (x*x + z*z);
  pos.setY(i, y);

  // 0..1 に正規化（中央に近いほど 1）
  const t = Math.max(0, Math.min(1, 1 + y / (K_VIS * 2)));

  // 色：低い(青) → 高い(黄)
  const r = t;
  const g = t * 0.85;
  const b = 1 - t;

  colors.push(r, g, b);
}

geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
geo.computeVertexNormals();

const groundMesh = new THREE.Mesh(
  geo,
  new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide
  })
);
groundMesh.receiveShadow = true;
scene.add(groundMesh);

/* =====================================================
   サイコロ（ここでは1個で安定確認）
===================================================== */
const DICE_SIZE = 0.6;

const diceMesh = new THREE.Mesh(
  new THREE.BoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE),
  [
    new THREE.MeshStandardMaterial({ map: createDiceTexture(2) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(5) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(1) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(6) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(3) }),
    new THREE.MeshStandardMaterial({ map: createDiceTexture(4) })
  ]
);
diceMesh.castShadow = true;
scene.add(diceMesh);

const diceBody = new CANNON.Body({
  mass: 1,
  shape: new CANNON.Box(new CANNON.Vec3(DICE_SIZE/2, DICE_SIZE/2, DICE_SIZE/2)),
  position: new CANNON.Vec3(0, 2.5, 0)
});
world.addBody(diceBody);

/* =====================================================
   ボタン操作
===================================================== */
function resetDice() {
  diceBody.velocity.setZero();
  diceBody.angularVelocity.setZero();
  diceBody.position.set(0, 2.5, 0);
  diceBody.quaternion.set(0, 0, 0, 1);
}

document.getElementById("btn").onclick = () => {
  resetDice();
  diceBody.applyImpulse(
    new CANNON.Vec3(
      (Math.random() - 0.5) * 0.18,
      0.6,
      (Math.random() - 0.5) * 0.18
    ),
    diceBody.position
  );
};

/* =====================================================
   ループ
===================================================== */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  world.step(1 / 60, clock.getDelta());

  // 自動復帰：見失わないため（デバッグ用）
  if (diceBody.position.y < -5) {
    resetDice();
  }

  diceMesh.position.copy(diceBody.position);
  diceMesh.quaternion.copy(diceBody.quaternion);

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
