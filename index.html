<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Chinchiro ‚Äì Simple Bowl</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #fff;
    font-family: system-ui, sans-serif;
  }
  #btn {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 28px;
    font-size: 18px;
    border: none;
    border-radius: 12px;
    background: #ffcc00;
    font-weight: bold;
    cursor: pointer;
  }
  #result {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 22px;
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="result"></div>
<button id="btn">„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã</button>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

/* ===============================
   „Çµ„Ç§„Ç≥„É≠„ÅÆÁõÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£
================================ */
function createDiceTexture(n) {
  const c = document.createElement("canvas");
  c.width = c.height = 256;
  const ctx = c.getContext("2d");

  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, 256, 256);
  ctx.fillStyle = "#000";

  const r = 18;
  const p = {
    tl:[64,64], tr:[192,64],
    ml:[64,128], mr:[192,128],
    bl:[64,192], br:[192,192],
    mc:[128,128]
  };
  const map = {
    1:["mc"],
    2:["tl","br"],
    3:["tl","mc","br"],
    4:["tl","tr","bl","br"],
    5:["tl","tr","mc","bl","br"],
    6:["tl","ml","bl","tr","mr","br"]
  };
  map[n].forEach(k=>{
    ctx.beginPath();
    ctx.arc(...p[k], r, 0, Math.PI*2);
    ctx.fill();
  });
  return new THREE.CanvasTexture(c);
}

/* ===============================
   Three.js
================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

// Áúü‰∏ä„Ç´„É°„É©
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 15, 0);
camera.lookAt(0, 0, 0);
camera.up.set(0, 0, -1);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ÂÖâ
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.DirectionalLight(0xffffff, 0.8);
light.position.set(5, 10, 5);
scene.add(light);

/* ===============================
   Cannon
================================ */
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

// Â∫ä
const floorBody = new CANNON.Body({ mass: 0 });
floorBody.addShape(new CANNON.Plane());
floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(floorBody);

/* ===============================
   „Å©„Çì„Å∂„ÇäÔºàÂÜÜÔºâ
================================ */
const BOWL_RADIUS = 5;

// ÂÜÖÂÅ¥
const bowlInner = new THREE.Mesh(
  new THREE.CircleGeometry(BOWL_RADIUS - 0.3, 64),
  new THREE.MeshStandardMaterial({ color: 0x8b5a2b })
);
bowlInner.rotation.x = -Math.PI/2;
scene.add(bowlInner);

// Á∏Å
const bowlRim = new THREE.Mesh(
  new THREE.RingGeometry(BOWL_RADIUS - 0.3, BOWL_RADIUS, 64),
  new THREE.MeshStandardMaterial({ color: 0xff0000 })
);
bowlRim.rotation.x = -Math.PI/2;
bowlRim.position.y = 0.01;
scene.add(bowlRim);

/* ===============================
   „Çµ„Ç§„Ç≥„É≠Ôºà3ÂÄãÔºâ
================================ */
const DICE_SIZE = 0.6;
const diceMeshes = [];
const diceBodies = [];

const materials = [
  new THREE.MeshStandardMaterial({ map: createDiceTexture(2) }),
  new THREE.MeshStandardMaterial({ map: createDiceTexture(5) }),
  new THREE.MeshStandardMaterial({ map: createDiceTexture(1) }),
  new THREE.MeshStandardMaterial({ map: createDiceTexture(6) }),
  new THREE.MeshStandardMaterial({ map: createDiceTexture(3) }),
  new THREE.MeshStandardMaterial({ map: createDiceTexture(4) })
];

for (let i = 0; i < 3; i++) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE),
    materials
  );
  scene.add(mesh);
  diceMeshes.push(mesh);

  const body = new CANNON.Body({
    mass: 1,
    shape: new CANNON.Box(
      new CANNON.Vec3(DICE_SIZE/2, DICE_SIZE/2, DICE_SIZE/2)
    )
  });
  world.addBody(body);
  diceBodies.push(body);
}

/* ===============================
   ÂÜÜÂÜÖÂà∂ÈôêÔºàÊúÄÈáçË¶ÅÔºâ
================================ */
function constrain(body) {
  const x = body.position.x;
  const z = body.position.z;
  const d = Math.sqrt(x*x + z*z);
  const limit = BOWL_RADIUS - 0.6;

  if (d > limit) {
    const nx = x / d;
    const nz = z / d;
    body.position.x = nx * limit;
    body.position.z = nz * limit;

    const v = body.velocity;
    const dot = v.x*nx + v.z*nz;
    if (dot > 0) {
      v.x -= dot * nx;
      v.z -= dot * nz;
    }
  }
}

/* ===============================
   „ÉÅ„É≥„ÉÅ„É≠Âà§ÂÆö
================================ */
function judge(vals) {
  const s = [...vals].sort();
  if (vals[0]===vals[1] && vals[1]===vals[2])
    return vals[0]===1 ? "üéâ „Éî„É≥„Çæ„É≠" : "‚ö° „Ç¢„É©„Ç∑";
  if (s+""==="1,2,3") return "üíÄ „Éí„Éï„Éü";
  if (s+""==="4,5,6") return "üî• „Ç∑„Ç¥„É≠";
  if (vals[0]===vals[1] || vals[1]===vals[2] || vals[0]===vals[2])
    return "üëâ ÂΩπ„ÅÇ„Çä";
  return "üòê ÂΩπ„Å™„Åó";
}

/* ===============================
   „Éú„Çø„É≥
================================ */
document.getElementById("btn").onclick = () => {
  document.getElementById("result").textContent = "";

  diceBodies.forEach((b,i)=>{
    b.position.set((i-1)*0.8, 1, 0);
    b.velocity.setZero();
    b.angularVelocity.setZero();

    const a = Math.random()*Math.PI*2;
    b.velocity.set(Math.cos(a)*2, 0, Math.sin(a)*2);
    b.angularVelocity.set(Math.random()*5,Math.random()*5,Math.random()*5);
  });

  setTimeout(()=>{
    const vals = diceBodies.map(()=>Math.floor(Math.random()*6)+1);
    document.getElementById("result").textContent = judge(vals);
  },2000);
};

/* ===============================
   „É´„Éº„Éó
================================ */
function animate(){
  requestAnimationFrame(animate);
  world.step(1/60);

  diceBodies.forEach((b,i)=>{
    constrain(b);
    diceMeshes[i].position.copy(b.position);
    diceMeshes[i].quaternion.copy(b.quaternion);
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
